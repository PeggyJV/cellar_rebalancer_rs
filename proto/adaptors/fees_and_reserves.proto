/*
* Protos for function calls to the FeesAndReserves and FeesAndReservesAdaptor contracts.
*/

syntax = "proto3";
package steward.v3;

option go_package = "/steward_proto";

import "adaptors/base.proto";

// TODO: Comments

// Represents call data for the FeesAndReserves and FeesAndReservesAdaptor contracts.
message FeesAndReservesAdaptorV1 {
    oneof function {
        /***** BASE ADAPTOR FUNCTIONS *****/

        // Represents function `revokeApproval(ERC20 asset, address spender)`
        RevokeApproval revoke_approval = 1;

        /***** ADAPTOR-SPECIFIC FUNCTIONS *****/

        // Represents function `updatePerformanceFee(uint32 performanceFee)`
        UpdatePerformanceFees update_performance_fees = 2;
        // Represents function `updateManagementFee(uint32 managementFee)`
        UpdateManagementFees update_management_fees = 3;
        // Represents function `changeUpkeepFrequency(uint64 newFrequency)`
        ChangeUpkeepFrequency change_upkeep_frequency = 4;
        // Represents function `changeUpkeepMaxGas(uint64 newMaxGas)`
        ChangeUpkeepMaxGas change_upkeep_max_gas = 5;
        // Represents function `setupMetaData(uint32 managementFee, uint32 performanceFee)`
        SetupMetaData setup_meta_data = 6;
        // Represents function `addAssetsToReserves(uint256 amount)`
        AddAssetsToReserves add_assets_to_reserves = 7;
        // Represents function `withdrawAssetsFromReserves(uint256 amount)`
        WithdrawAssetsFromReserves withdraw_assets_from_reserves = 8;
        // Represents function `prepareFees(uint256 amount)`
        PrepareFees prepare_fees = 9;
    }

    /*
    *
    *
    *
    */
    message UpdatePerformanceFees {
        uint32 performance_fee = 1;
    }

    /*
    *
    *
    *
    */
    message UpdateManagementFees {
        uint32 management_fee = 1;
    }

    /*
    *
    *
    *
    */
    message ChangeUpkeepFrequency {
        uint64 new_frequency = 1;
    }

    /*
    *
    *
    *
    */
    message ChangeUpkeepMaxGas {
        uint64 new_max_gas = 1;
    }

    /*
    *
    *
    *
    */
    message SetupMetaData {
        uint32 management_fee = 1;
        uint32 performance_fee = 2;
    }

    /*
    *
    *
    *
    */
    message AddAssetsToReserves {
        string amount = 1;
    }

    /*
    *
    *
    *
    */
    message WithdrawAssetsFromReserves {
        string amount = 1;
    }

    /*
    *
    *
    *
    */
    message PrepareFees {
        string amount = 1;
    }
}

message FeesAndReservesAdaptorV1Calls {
    repeated FeesAndReservesAdaptorV1 calls = 1;
}

// /**
//      * @notice Strategists are free to update their cellar's performance fee as they see fit.
//      *         Ultimately the competition between strategists will keep this in check, since
//      *         a strategist could out perform another strategist simply because they take a smaller fee.
//      */
//      function updatePerformanceFee(uint32 performanceFee) public {
//         feesAndReserves().updatePerformanceFee(performanceFee);
//     }

//     /**
//      * @notice Strategists are free to update their cellar's management fee as they see fit.
//      *         Ultimately the competition between strategists will keep this in check, since
//      *         a strategist could out perform another strategist simply because they take a smaller fee.
//      */
//     function updateManagementFee(uint32 managementFee) public {
//         feesAndReserves().updateManagementFee(managementFee);
//     }

//     /**
//      * @notice Allows strategist to change how frequently they want their cellars fees calculated.
//      */
//     function changeUpkeepFrequency(uint64 newFrequency) public {
//         feesAndReserves().changeUpkeepFrequency(newFrequency);
//     }

//     /**
//      * @notice Allows strategist to change the max gas they are willing to pay for fee calculations..
//      */
//     function changeUpkeepMaxGas(uint64 newMaxGas) public {
//         feesAndReserves().changeUpkeepMaxGas(newMaxGas);
//     }

//     /**
//      * @notice Setup function strategist must call in order to use FeesAndReserves.
//      */
//     function setupMetaData(uint32 managementFee, uint32 performanceFee) public {
//         feesAndReserves().setupMetaData(managementFee, performanceFee);
//     }

//     /**
//      * @notice Strategists are free to add/remove assets to reserves because it allows them to
//      *         inject yield into the cellar during time of under performance, and reserve yield
//      *         during times of over performance.
//      */
//     function addAssetsToReserves(uint256 amount) public {
//         (ERC20 asset, , , , , , , , , ) = feesAndReserves().metaData(Cellar(address(this)));
//         amount = _maxAvailable(asset, amount);
//         asset.safeApprove(address(feesAndReserves()), amount);
//         feesAndReserves().addAssetsToReserves(amount);

//         // Make sure that `feesAndReserves` has zero allowance to Cellar assets.
//         _revokeExternalApproval(asset, address(feesAndReserves()));
//     }

//     /**
//      * @notice Strategists are free to add/remove assets to reserves because it allows them to
//      *         inject yield into the cellar during time of under performance, and reserve yield
//      *         during times of over performance.
//      */
//     function withdrawAssetsFromReserves(uint256 amount) public {
//         feesAndReserves().withdrawAssetsFromReserves(amount);
//     }

//     /**
//      * @notice Allows strategists to take pending fees owed, and set them up to be distributed using `sendFees` in FeesAndReserves contract.
//      */
//     function prepareFees(uint256 amount) public {
//         feesAndReserves().prepareFees(amount);
//     }
